## REx
```ruby
irb(main):001:1* class Foo
irb(main):002:1*   @@var = 0
# Fooクラスにクラス変数@@varが定義
irb(main):003:2*   def var
irb(main):004:2*     @@var
# クラス変数は継承されたクラスにも反映されるので、
# そのクラス変数が定義されているクラスとそのサブクラスの全インスタンスで共有
irb(main):005:1*   end
irb(main):006:2*   def var=(value)
irb(main):007:2*     @@var = value
# クラス変数は継承されたクラスにも反映されるので、
# そのクラス変数が定義されているクラスとそのサブクラスの全インスタンスで共有
irb(main):008:1*   end
irb(main):009:0> end
=> :var=
irb(main):010:1* class Bar < Foo
irb(main):011:0> end
# FooクラスのインスタンスfooとFooクラスを継承しているBarクラスの
# インスタンスbarで@@varの値を参照・更新している
=> nil
irb(main):012:0> foo = Foo.new
=> #<Foo:0x00005d5102836318>
irb(main):013:0> foo.var += 1
=> 1
# Fooクラスの@@varは共有される
irb(main):014:0> bar = Bar.new
=> #<Bar:0x00005d51025540f0>
irb(main):015:0> bar.var += 2
=> 3
# Fooクラスの@@varは共有される
irb(main):016:0> puts "#{foo.var}/#{bar.var}"
3/3
# なので実行結果は3/3となる
```

### たとえば「おかしのびん」を使って説明すると…

🍬 クラス変数は「みんなで使うおかしのびん」

- @@var は「クラス全体で1つだけある変数」

- これは、Foo というクラスと、その子どもである
Bar クラスでも「同じびん」を使っている(継承しているから)

### 実験してみよう！

- 最初にびんは空っぽ（0）

- foo.var += 1 をすると、びんに1つおかしを入れる → 中身は 1
  
- でも += 1 は実はこういう意味：
```Ruby
foo.var = foo.var + 1
```
- つまり、まず中身（0）を取り出して、1を足して、またびんに戻す。

- 次に bar.var += 2 をすると：

- 今びんの中は 1

- それに 2 を足して → 3
  
- びんの中は 3 になる

### だから foo.var も bar.var も同じ「びん」を見ている！
```Ruby
puts "#{foo.var}/#{bar.var}"
```

これは「びんの中身を2回見ている」だけなので、どちらも 3。だから 3/3 と表示される


```Ruby
irb(main):020:0> arr = [1,2].product([3,4]).transpose
=> [[1, 1, 2, 2], [3, 4, 3, 4]]
irb(main):021:0> p arr
[[1, 1, 2, 2], [3, 4, 3, 4]]
=> [[1, 1, 2, 2], [3, 4, 3, 4]]
```
productはレシーバーの配列と引数の配列からそれぞれ1つ要素を取り出し新しい配列を作成し、

全ての配列を要素とする配列を返す。

productの例
```Ruby
[1, 2].product([3, 4])
```
```Ruby
# 実行結果

# [[1, 3], [1, 4], [2, 3], [2, 4]]
```
transposeはレシーバーの配列から行と列を入れ替えた配列を作成し返す。

transposeの例
```Ruby
[[1, 3],
 [1, 4],
 [2, 3],
 [2, 4]
].transpose
```
```Ruby
# 実行結果
# [[1, 1, 2, 2], [3, 4, 3, 4]]
```

### お弁当で考えてみよう！
🥢 product は「おかずの組み合わせを全部作る」
たとえば：
- おにぎりが2つある → [1, 2]
- おかずが2つある → [3, 4]
これで「おにぎりとおかずのセット」を全部作ると…
```Ruby
[1, 2].product([3, 4])
```
これはこうなる：
```Ruby
[[1, 3], [1, 4], [2, 3], [2, 4]]
```

つまり：
- おにぎり1 + おかず3
- おにぎり1 + おかず4
- おにぎり2 + おかず3
- おにぎり2 + おかず4
  
ぜんぶの組み合わせを作ってくれる

🔄 transpose は「縦横をひっくり返す」
さっきの組み合わせを、表にしてみよう：
```Ruby
[1, 3]
[1, 4]
[2, 3]
[2, 4]
```
これを transpose すると…
```Ruby
[[1, 1, 2, 2], [3, 4, 3, 4]]
```
つまり：
- 1列目（おにぎりたち）→ [1, 1, 2, 2]
- 2列目（おかずたち）→ [3, 4, 3, 4]

縦と横を入れかえる！

まとめると…
| 操作 | 意味 | 
| -------- | -------- |
| product | すべての組み合わせを作る（おにぎり×おかず） | 
| transpose | 縦と横を入れ替える（行→列、列→行） | 

```Ruby
arr = [1,2].product([3,4]).transpose
```
これは：
- [1, 2].product([3, 4]) → 組み合わせを作る
- .transpose → たてよこを入れかえる
だから結果は：
```Ruby
[[1, 1, 2, 2], [3, 4, 3, 4]]
```

