# REx

```irb
~$ irb
irb(main):001:1* arr = [
irb(main):002:1*   "a".to_i(36),
irb(main):003:1*   "070".to_i(0),
irb(main):004:1*   nil.to_i,
irb(main):005:1*   "0b0001".to_i
irb(main):006:0> ]
=> [10, 56, 0, 0]
irb(main):007:0> p arr
[10, 56, 0, 0]
=> [10, 56, 0, 0]
```
文字列を整数に変換すると2進数、8進数、10進数、16進数に切り替わるものの、何が何だか全然わからないので整理してみた

### 「to_i」は魔法のメガネ！

Rubyの "文字列" に .to_i をつけると、「数字に変える魔法のメガネ」をかけたみたいに、文字を数字に変えてくれる

たとえば：
```Ruby
"123".to_i  # => 123
```
これは「123」という文字を、本物の数字123に変えてくれる！

でも、変えられない文字はどうなる？
```Ruby
"abc".to_i  # => 0
```
これは「数字じゃないな」ってことで、0になる。(文字列なので)

変えられないとき魔法の眼鏡くんは「とりあえず0にしとくか〜」って感じ！

途中まで数字なら？
```Ruby
"12abc".to_i  # => 12
```
これは「12までは数字っぽいけど、abcはわかんない！」ってことで、12だけ変えてくれる！

🔢 いろんな数の数え方がある！
ふつうの数え方（10進数）だけじゃなくて、2進数とか16進数とか、いろんな数え方がある

たとえば：

| 数え方 | 名前 | 例 | 意味（10進数で） | 
| -------- | -------- | -------- | -------- | 
| 2進数 | binary | "0b10" | 2 | 
| 8進数 | octal | "010" | 8 | 
| 10進数 | decimal | "0d10" | 10 | 
| 16進数 | hex | "0x10" | 16 | 

🧪 .to_i(0) は「自動で見分けてくれるモード」
```Ruby
"0x10".to_i(0)  # => 16
"0b10".to_i(0)  # => 2
```

この「0」は「自分で見分けてね！」って意味。

数字の前にある「0x」「0b」などのヒントを見て、どの数え方かを判断してくれる！

🧼 まとめると…
- "123".to_i → 文字を数字に変える
- "abc".to_i → 数字じゃない → 0になる
- "12abc".to_i → 12だけ変える
- .to_i(2) → 2進数として読む
- .to_i(0) → 自動で数え方を判断！

### irb(main):002:1*   "a".to_i(36)が10の理由
- "a" は文字列だけど、to_i(36) は「36進数として読んでね」って意味。
- 36進数では、"a" は10を表す！（a=10, b=11, ..., z=35）

  どゆこと？

🧙‍♂️ これは「36人の数字の国」のお話！
ふつうの数字の国（10進数）には、0〜9の10人しかいない

でも、36進数の国には…
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
a, b, c, d, e, f, g, ..., z（←アルファベットも数字の仲間！）

つまり、a は10番目の数字！

だから：
```Ruby
"a".to_i(36)  # => 10
```
は、「aって36進数では10なんだよ〜」ってこと！

🧠 ポイント：36進数では、アルファベットも数字の仲間


### irb(main):003:1*   "070".to_i(0)が56の理由
- to_i(0) は「自動で数え方を判断してね」って意味。
- "070" は 先頭が0 なので、8進数と判断される。
- 8進数の 070 は、10進数で 56！
🧠 ポイント：先頭が - "0" だと8進数になる

どゆこと？

これは「数字の探偵」がヒントを見つけるお話！

Rubyくんは数字を読むとき、先頭のヒントを見て「これは何進数かな？」って考える
```Ruby
"070".to_i(0)
```
この "070" の先頭には 0 があるよね？

Rubyくんはこう考えます：
```
「おっ、先頭が0だ！これは8進数かも！」
```

8進数っていうのは、「0〜7」までしか使わない数え方。

だから "070" は、8進数で「7×8 + 0 = 56」ってこと！






